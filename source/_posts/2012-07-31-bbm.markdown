---
layout: post
title: "Backbone and Ember in the non-Todo world - Part 2 - Backbone Marionette"
date: 2012-07-31 05:44
comments: true
categories: JavaScript Ember Backbone.js
---
Like many, my first foray into the javascript mv* world was with <a href="http://documentcloud.github.com/backbone/" target="_blank">Backbone.js</a>
 and also like many, I got it completely wrong the first time round.  My mindset was
still very much stuck in the mode of holding state in the DOM with the use of data
attributes and the like.  My views were tightly coupled and the resulting code
was merely a thin veneer over JQuery.  On the other side however, I was
instantly enamoured with the organisational patterns and logical
abstractions of models, collections and views that backbone brought to the table.

Shortly after that, I discovered coffeescript and javascript suddenly took on a
degree of order that I was unused to.  On I plodded until I had my first
realisation and that was that I was writing even more code than I had previously when
I was maniupulating the DOM directly with jQuery.  I was writing a lot of repetitive code like
this:
{% codeblock%}
ParentView = Backbone.View.extend
  @template = _.template($('#template_id').html())
  render: =>
    childViews = []
    @collection.each (model) =>
      childView = new ReportItemView({model: model})
      childViews.push(childView.render().el)

    $(@el).append(childViews)
    @
{%endcodeblock%}
All the above code is doing is iterating over this particular backbone view's collection and
creating new child views that are attached to the parent view's DOM element. The
above code is displaying a whole world of wrong. If
your backbone code is littered with lots of the above code then I think it is safe
to say that you are doing it wrong or you are somebody who likes writing lots of
repetitive code.

What became obvious after a while was that backbone was leaving far too many
choices up to the developer.  It felt more like a framework base than an actual
framework.  At this point I discovered ember and quickly fell in love but I had
too much backbone code in the wild to refactor to ember.

I'd been a keen reader of Derick Bailey's <a href="http://lostechies.com/derickbailey/">blog</a> for some 
time and it turned out that he had his own framework built on top of backbone called 
 <a href="https://github.com/derickbailey/backbone.marionette" target="_blank">backbone.marionette</a>.

Backbone.Marionette grandly calls itself a composite application architecture which
means it is a serious of smaller building blocks that you can pick and choose from
to help you solve the problem at hand.  What backbone marionette gave me was the
missing bits of backbone that I did not have to write myself.

I will now list in no particular order how backbone.marionette fills in the missing
gap:

##Template Cache##
If you are using Backbone out of the box then you are either need to roll your own
tempate manager or you are going to have to incur the compiling penalty every time you use the template.
  If you are not managing your backbone templates and recompiling client side
  everytime then please stop now.  There is a significant overhead in doing this and
  this is a very quick win.  

  Below is the code from backbone.marionette that ensures that the template is only
  loaded once:
{% gist 3224350 %}
The above code uses a familiar javascript caching strategy of using javascript's
hashtable like ability to check if the template is already in memory. 
##Better View Abstractions##
The problem with backbone is that everything is a view containing a view, containing a
view.  It is hard for the mind to grasp this generic abstraction when things get
more detailed.  

This is best illustrated with an example of what I have been working on recently.
Below is a screenshot of a windows explorer like application that segrates the page into the folder structure
on the left and the individual file detail of the parent folder on the right.
{%img /images/spa/bbox.png%}
The first useful abstraction is the layout.  Anybody familiar with MVC frameworks
will  instantly know what a layout is or you may have known them as master pages in .NET.  
Layouts are the whole picture or everything.  Child
views or regions are subsections of the layout.  In this example, the layout
encompasses both the folder structure on the left and the individual files for the
selected folder structure on the right.  Below is the code for the above layout:
{% gist 3233594 %}
- On **line 1** of the above gist, a new backbone.marionette module is created that adds a
bit of encapsulation and behaves pretty much like the revealing module pattern.
- On **line 2**, a private **Layout** variable is created that acts as a pointer to
  the Backbone Marionette **Layout** definition.  You should note that extend is
  used here instead of create.  We have not created the layout instance yet, we have
  only created the definition.
- On lines **5 to 8**, 2 backbone.marionette regions are specified.  A
  Backbone.marionette region is used to define visual regions of your application.
  Each region is defined with a JQuery selector and in the above example, a treeview
  region is created for the left pain and a documents region is created for the
  right pain.
- On **line 10** the events has is created for the 2 buttons on the page that deal
  with creating a new folder or adding a new file.
- On **line 24** an **addInitializer** callback is added.  These initializers get
  fired by the backbone.marionette runtime when the backbone.marionette application
  gets created and is bound to the application object.
- **Line 25** creates an instance of the layout that was defined on **line 2**.
- **Line 27** defines a handler for the backbone.marionette **show** event that is
  fired after a view is rendered.  A backbone.marionette layout, extends a
  marionette view.
- On **LIne 28** we fire an event named **layout:rendered** that other subscribers
  can subscribe.  An example of such a subscriber is below where I initialise the
  treeview.  I need to wait until the layout has been added to the DOM in order for
  this to act correctly:
  {% codeblock %}
DocumentManager.vent.on("layout:rendered", function(){
  $('#explorer').treeview({collapsed: false});
});
  {% endcodeblock %}
##CompositeView and ItemView##
Backbone.Marionette contains a cure for the horrible tightly coupled looping code I
showed at the start of this post.  Backbone marionette comes with a mechanisim for
defining
##Event Aggregator##
An event aggregator is an application level pub/sub mechanism that allows various
pieces of an otherwise segmented and disconnected system to communicate with each
other.
