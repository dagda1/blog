---
layout: post
title: "Backbone and Ember in the non-Todo world - Part 2 - Backbone Marionette"
date: 2012-07-31 05:44
comments: true
categories: JavaScript Ember Backbone.js
---
Like many, my first foray into the javascript mv* world was with <a href="http://documentcloud.github.com/backbone/" target="_blank">Backbone.js</a>
 and also like many, I got it completely wrong the first time round.  My mindset was
still very much stuck in the mode of holding state in the DOM with data
attributes and the like.  My views were tightly coupled and the resulting code
was merely a thin veneer over JQuery.  On the other side however, I was
instantly enamoured with the organisational patterns and logical
abstractions of models, collections and views that backbone brought to the table.

Shortly after that, I discovered coffeescript and javascript suddenly took on a
degree of order that I was unused to.  On I plodded until I had my first
realisation and that was that I was writing even more code than previously when
I maniupulating the DOM directly.  I was writing a lot of repetitive code like
this:
{% codeblock%}
render: =>
  childViews = []
  @collection.each (model) =>
    childView = new ReportItemView({model: model})
    childViews.push(childView.render().el)

  $(@el).append(childViews)
  @
{%endcodeblock%}
All the above code is doing is iterating over this particular backbone view's collection and
creating new child views that are attached to the parent view's DOM element.
This quickly gets tedious in the extreme but what is also not entirely evident
or at least it was not to me is that everytime we execute this render method,
we are keep adding views into memory.  Backbone does not or at least it does
not at this time of writing have a dispose method on its views.  I did come up
with a workaround which I mentioned in an earlier <a target="_blank" href="http://www.thesoftwaresimpleton.com/blog/2011/11/13/backbone-js---lessons-learned/">post</a>.

What became obvious after a while was that backbone was leaving far too many
choices up to the developer.  It felt more like a framework base than an actual
framework.  At this point I discovered ember and quickly fell in love but I had
too much backbone code in the wild to refactor to ember but I then discovered <a href="https://twitter.com/#!/derickbailey" target="_blank">Derick Bailey's</a> excellent <a href="https://github.com/derickbailey/backbone.marionette" target="_blank">backbone.marionette</a>.

I'd been a keen reader of Derick's <a href="http://lostechies.com/derickbailey/">blog</a> for some time so choosing marionette was a no brainer.

I will now list in no particular order how backbone.marionette fills in the missing
gap:

##Template Cache##
If you are using Backbone out of the box then you are either need to roll your own
tempate manager or you are going to have to incur the compiling penalty every time you use the template.
  If you are not managing your backbone templates and recompiling client side
  everytime then please stop now.  There is a significant overhead in doing this and
  it is a very quick win.  

  Below is the code from backbone.marionette that ensures that the template is only
  loaded once:
{% gist 3224350 %}
The above code uses a familiar javascript caching strategy.  I believer there are
some initiatives to compile client side templates on the server.
##Composite Application Architecture##
The problem with backbone is that everything is a view containing a view, containing a
view.  It is hard for the mind to grasp this generic abstraction when things get
more detailed.  

This is best illustrated with an example of what I have been working on recently.
Below is a screenshot of a windows explorer like application that segrates the page into the folder structure
on the left and the individual file detail of the parent folder on the right.
{%img /images/spa/bbox.png%}
The first useful abstraction is the layout.  Anybody familiar with MVC frameworks
will be familiar with layouts.  Layouts are the whole picture or everything.  Child
views or regions are subsections of the layout.  In this example, the layout
encompasses both the folder structure on the left and the individual files for that
folder structure on the right.  Below is the code for the above layout:
{% gist 3233594 %}
- On **line 1** of the above gist, a new backbone.marionette module is created that adds a
bit of encapsulation and behaves pretty much like the revealing module pattern.
- On **line 2**, a private **Layout** variable is created that acts as a pointer to
  the Backbone Marionette **Layout** definition.  You should note that extend is
  used here instead of create.  We have not created the layout instance yet, we have
  only created the definition.
- On lines **5 to 8**, 2 backbone.marionette regions are specified.  A
  Backbone.marionette region is used to define visual regions of your application.
  Each region is defined with a JQuery selector and in the above example, a treeview
  region is created for the left pain and a documents region is created for the
  right pain.
- On **line 10** the events has is created for the 2 buttons on the page that deal
  with creating a new folder or adding a new file.
- On **line 24** an **addInitializer** callback is added.  These initializers get
  fired by the backbone.marionette runtime when the backbone.marionette application
  gets created and is bound to the application object.
- **Line 25** creates an instance of the layout that was defined on **line 2**.
- **Line 27** defines a handler for the backbone.marionette **show** event that is
  fired after a view is rendered.  A backbone.marionette layout, extends a
  marionette view.
- On **LIne 28** we fire an event named **layout:rendered** that other subscribers
  can subscribe.  An example of such a subscriber is below where I initialise the
  treeview.  I need to wait until the layout has been added to the DOM in order for
  this to act correctly:
  {% codeblock %}
DocumentManager.vent.on("layout:rendered", function(){
  $('#explorer').treeview({collapsed: false});
});
  {% endcodeblock %}
