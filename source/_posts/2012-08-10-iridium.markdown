---
layout: post
title: "Iridium - a toolchain for javascript development'"
date: 2012-08-10 10:31
comments: true
categories: JavaScript Ember
---
I want to give a shout out to a very new and very interesting project called
<a target="_blank" href="https://github.com/radiumsoftware/iridium/">iridium</a> from 
<a target="_blank" href="https://twitter.com/adman65">Adam Hawkins</a> who blogs at
 <a target="_blank" href="http://www.broadcastingadam.com/">BroadcastingAdam</a>.  Iridium aims to provide some much needed tooling to the new front end javascript/coffeescript project type that is popularised by the javascript mv* space.

With more and more of the application code finding its way onto the client in the form of
javascript or coffeescript, there is a necessity to make a clear separation between between the front end client code and the backend server code.  With Gems like the <a href="https://github.com/spastorino/rails-api" target="_blank">rails-api</a> gem stripping away all the cruft that is associated with serving html from a rails application, wouldn't it be nice if you could spin up a new javascript/coffeescript project with just a few keystrokes?
##Problem 1 - Lack of Front End Project Guidance##
Gone are the days (I wish) when client side code and server side code lived side by side in a one size fits all monolithic project structure.  Good practice dictates that you should segregate these two distinct layers
into two (or more) orthogonal projects that can evolve at their own pace.

Rails brought conformity to the mvc pattern by creating a guaranteed project structure for every rails project.  Wouldn't it be nice if we could bring some order to the new breed of client side only project?
##The Solution##
<a target="_blank" href="https://github.com/radiumsoftware/iridium/">Iridium</a> aims
to add some much needed tooling to the front end project space and sets out with the
following goals:-

- CLI driven interactions
- Expose as little Ruby as possible
- Focus on JS/CSS/HTML
- Make JS testable

###First Steps###
The first thing to do is to ensure that you have <a href="http://casperjs.org/" target="_blank">casperjs</a> installed.  Casperjs is what iridium uses as its integration test framework.  Full installation details can be found <a href="http://casperjs.org/installation.html" target="_blank">here</a>.  I personally used homebrew to install casperjs.

Next, you need to add the following entries to an existing project's Gemfile or create a new Gemfile in the root of a new project:
{% gist 3313904 %}
A quick **bundle install** will install the specified gems and then you can start using iridium.

Iridium solves the first problem by allowing me to spin up a new client side project with most of the initial decision making made for me.

I can be up and running by simply entering the following command while in the project directory.
{% codeblock %}
bundle exec iridium app .
{% endcodeblock %}
The above command will create the following output:
{% blockquote %}
create  app
      create  app/images
      create  app/javascripts/app.coffee
      create  app/javascripts/boot.coffee
      create  app/javascripts/controllers
      create  app/javascripts/models
      create  app/javascripts/templates
      create  app/javascripts/views
      create  app/public
      create  app/stylesheets/app.scss
      create  app/vendor/javascripts
      create  app/vendor/stylesheets
      create  site
      create  test
      create  test/controllers
      create  test/helper.coffee
      create  test/integration/navigation_test.coffee
      create  test/models
      create  test/support/qunit.js
      create  test/support/sinon.js
      create  test/templates
      create  test/unit/truth_test.coffee
      create  test/views
      create  application.rb
      create  readme.md
      create  .gitignore
{% endblockquote %}

Not only can we now guarantee where everything in our client project lives but iridium has also provided some smart defaults for us:

- We will be using <a href="http://sass-lang.com/" target="_blank">SASS</a> as the css framework of choice and an **app.scss** file is created in **app/stylesheets/app.scss**.
- We will be testing and we will be writing unit and integration tests.  This is why the folders have been created and we must use them.
- We will be using <a href="http://qunitjs.com/" target="_blank">QUnit</a> for unit tests.
- We will be using <a href="http://casperjs.org/" target="_blank">Casperjs</a> for integration tests.  Integration tests are often overlooked in the front end world.
- I will be using sinon.js to mock or stub out any async. calls when unit testing.
- The <a href="http://rubydoc.info/github/livingsocial/rake-pipeline/master/file/README.yard" target="_blank">Rake-pipeline</a> is used for javascript loading and for packaging assets for deployment.

###The Case for Rake-Pipeline###

The rake-pipeline is a better fit for single page applications than an asynchronous module loader like <a herf="http://requirejs.org/" target="_blank">requirejs</a> because it bundles all your dependencies and individual files into a single script.  Rails does all this concatenation and minification transparently behind the scenes without you having to do anything at all.  Using the rails asset pipeline eases rolling deployment for you because while in development scripts are served as individual files without minification and in production scripts are served as minified and concatenated.

##Problem 2 - Testing the client code##
The rise of the client side MV* framework and the proliferation of code on the client has made the call test, a more important one than ever.  The tide does appear to be turning on testing client code with the rise of important testing frameworks like <a href="http://pivotal.github.com/jasmine/" target="_blank">Jasmine</a> and <a href="http://qunitjs.com/" target="_blank">QUnit</a> but adoption of this practice could be better.  Part of the difficulty is getting set up.  Why should I have to concern myself with wiring everything together, every time I start a new project.  Anybody who initially wrestled with Jasmine and the rails asset pipeline will know exactly what I mean when by **wrestling**.

Anybody from a rails background will be comfortable with running particular flavours of
test suites (unit/integration/functional) via rake's uniform command line interface.
  Iridium gives you the same capabilities and makes the clear distinction between unit tests and integration tests.
  
Projects like <a href="sinonjs.org" target="_blank">sinon.js</a> or <a href="https://github.com/appendto/jquery-mockjax/" target="_blank">jquery-mockajax</a>
  provide a means to stub out or mock the server side the API calls that are either not yet available or not applicable for writing resource free unit tests.